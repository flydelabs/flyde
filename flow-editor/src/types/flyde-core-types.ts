// This file is auto-generated
export const flydeCoreTypes = `// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../zod
//   ../../../../rxjs
//   ../../../../debug
//   ../../../../react

declare module '@flyde/core' {
    export * from "@flyde/core/common";
    import { Pos, OMap } from "@flyde/core/common";
    import { FlydeFlow } from "@flyde/core/flow-schema";
    import { VisualNode, InputPinsConfig, NodeDefinition, NodeOrMacroDefinition, MacroNodeDefinition } from "@flyde/core/node";
    export * from "@flyde/core/connect/helpers";
    export * from "@flyde/core/execute";
    export * from "@flyde/core/simplified-execute";
    export * from "@flyde/core/node";
    export * from "@flyde/core/node/get-node-with-dependencies";
    export * from "@flyde/core/flow-schema";
    export * from "@flyde/core/types/connections";
    export * from "@flyde/core/improved-macros/improved-macros";
    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from "@flyde/core/improved-macros/improved-macro-utils";
    export interface InstanceViewData {
        id: string;
        nodeIdOrGroup: string | VisualNode;
        pos: Pos;
        visibleOptionalInputs?: string[];
        inputConfig: InputPinsConfig;
    }
    export type NodesDefCollection = OMap<NodeDefinition>;
    export type MacrosDefCollection = OMap<MacroNodeDefinition<any>>;
    export interface NodeLibraryGroup {
        title: string;
        nodes: NodeOrMacroDefinition[];
    }
    export interface NodeLibraryData {
        groups: NodeLibraryGroup[];
    }
    export type ImportablesResult = {
        importables: Record<string, NodesDefCollection>;
        errors: {
            path: string;
            message: string;
        }[];
    };
    export type ImportableMacrosResult = {
        importableMacros: Record<string, MacrosDefCollection>;
        errors: {
            path: string;
            message: string;
        }[];
    };
    export interface FlowJob {
        flow: FlydeFlow;
        id: string;
    }
}

declare module '@flyde/core/common' {
    export * from "@flyde/core/common/test-data-creator";
    export * from "@flyde/core/common/utils";
    export * from "@flyde/core/common/debug-logger";
    export * from "@flyde/core/common/capped-array-debounce";
    export * from "@flyde/core/common/utils";
    export * from "@flyde/core/common/hasher";
    export * from "@flyde/core/common/value-builders";
    export * from "@flyde/core/common/data-shaper";
    export * from "@flyde/core/common/full-ins-id-path";
    export const DepGraph: any;
}

declare module '@flyde/core/flow-schema' {
    import { z } from "zod";
    import { VisualNode, NodeDefinition, ResolvedVisualNode } from "@flyde/core/node";
    import { CodeNode } from "@flyde/core/improved-macros/improved-macros";
    export type FlydeFlow = {
        imports?: Record<string, String[]>;
        node: VisualNode;
    };
    export interface ImportSource {
        path: string;
        export?: string;
    }
    export type ImportedNodeDefinition = NodeDefinition & {
        source: ImportSource;
    };
    export type ImportedNode = (VisualNode | CodeNode) & {
        source: ImportSource;
    };
    export type ImportedNodeDef = NodeDefinition & {
        source: ImportSource;
    };
    export type ResolvedDependenciesDefinitions = Record<string, ImportedNodeDefinition>;
    export type ResolvedFlydeFlowDefinition = {
        main: ResolvedVisualNode;
        dependencies: ResolvedDependenciesDefinitions;
    };
    export type ResolvedDependencies = Record<string, ImportedNode>;
    export type ResolvedFlydeRuntimeFlow = {
        main: ResolvedVisualNode;
        dependencies: ResolvedDependencies;
    };
    export type ResolvedFlydeFlow = ResolvedFlydeFlowDefinition | ResolvedFlydeRuntimeFlow;
    export const flydeFlowSchema: z.ZodObject<{
        imports: z.ZodDefault<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>>>>;
        node: any;
    }, "strict", z.ZodTypeAny, {
        imports?: Record<string, string | string[]>;
        node?: any;
    }, {
        imports?: Record<string, string | string[]>;
        node?: any;
    }>;
}

declare module '@flyde/core/node' {
    export * from "@flyde/core/node/node-instance";
    export * from "@flyde/core/node/node-pins";
    export * from "@flyde/core/node/pin-config";
    export * from "@flyde/core/node/nodeFromSimpleFunction";
    export * from "@flyde/core/node/node-instance-error";
    export * from "@flyde/core/node/node";
}

declare module '@flyde/core/connect/helpers' {
    import { NodeDefinition } from "@flyde/core/node";
    import { ConnectionData, ConnectionNode, ExternalConnectionNode, InternalConnectionNode } from "@flyde/core/types/connections";
    export const THIS_INS_ID = "__this";
    export const ERROR_PIN_ID = "__error";
    export const TRIGGER_PIN_ID = "__trigger";
    export const getNodeInputs: (node: NodeDefinition) => {
        __trigger: import("../node").InputPin;
    };
    export const getInputName: (pinId: string) => string;
    export const getOutputName: (pinId: string) => string;
    export const getNodeOutputs: (node: NodeDefinition) => {
        __error: import("../node").OutputPin;
    };
    export const isExternalConnectionNode: (node: ConnectionNode) => node is ExternalConnectionNode;
    export const isInternalConnectionNode: (node: ConnectionNode) => node is InternalConnectionNode;
    export const isExternalConnection: ({ from, to }: ConnectionData) => boolean;
    export const isInternalConnection: (conn: ConnectionData) => boolean;
    export const externalConnectionNode: (pinId: string) => ExternalConnectionNode;
    export const connectionNode: (insId: string, pinId: string) => ConnectionNode;
    export const connectionNodeEquals: (conn1: ConnectionNode, conn2: ConnectionNode) => boolean;
    export const connectionDataEquals: (cd1?: ConnectionData, cd2?: ConnectionData) => boolean;
    export function connectionData(from: string, to: string, delayed?: boolean): ConnectionData;
    export function connectionData(from: [string, string], to: [string, string], delayed?: boolean): ConnectionData;
    export function connectionData(from: [string, string], to: [string], delayed?: boolean): ConnectionData;
    export function connectionData(from: [string], to: [string, string], delayed?: boolean): ConnectionData;
    export const connection: (from: ConnectionNode, to: ConnectionNode, delayed?: boolean) => ConnectionData;
}

declare module '@flyde/core/execute' {
    import { Subject } from "rxjs";
    export * from "@flyde/core/execute/debugger";
    import { Node, InternalCodeNode, NodeInputs, NodeOutputs, NodeInstanceError, NodeState, NodesCollection } from "@flyde/core/node";
    import { OMap, OMapF } from "@flyde/core/common";
    import { Debugger } from "@flyde/core/execute/debugger";
    export type SubjectMap = OMapF<Subject<any>>;
    export type ExecutionState = Map<string, any>;
    export type CancelFn = () => void;
    export type InnerExecuteFn = (node: Node, args: NodeInputs, outputs: NodeOutputs, insId: string) => CancelFn;
    export type CodeExecutionData = {
            node: InternalCodeNode;
            inputs: NodeInputs;
            outputs: NodeOutputs;
            resolvedDeps: NodesCollection;
            _debugger?: Debugger;
            /**
                * If the node is an instance of another node, this is the id of the instance.
                * If the node is the root node, this is "__root".
                * Used for debugger events and state namespacing
                */
            insId: string;
            /**
                * A full path of ancestor insIds, separated by dots.
                * Used for debugger events and state namespacing
                */
            ancestorsInsIds?: string;
            extraContext?: Record<string, any>;
            mainState: OMap<NodeState>;
            onError: (err: any) => void;
            onBubbleError: (err: any) => void;
            onCompleted?: (data: any) => void;
            onStarted?: () => void;
    };
    export const INNER_STATE_SUFFIX = "_inner";
    export const INPUTS_STATE_SUFFIX = "_inputs";
    export type ExecuteFn = (params: ExecuteParams) => CancelFn;
    export type ExecuteParams = {
            node: Node;
            resolvedDeps: NodesCollection;
            inputs: NodeInputs;
            outputs: NodeOutputs;
            _debugger?: Debugger;
            insId?: string;
            ancestorsInsIds?: string;
            mainState?: OMap<NodeState>;
            onBubbleError?: (err: NodeInstanceError) => void;
            extraContext?: Record<string, any>;
            onCompleted?: (data: any) => void;
            onStarted?: () => void;
    };
    export const ROOT_INS_ID = "__root";
    export const GLOBAL_STATE_NS = "____global";
    export const execute: ExecuteFn;
}

declare module '@flyde/core/simplified-execute' {
    import { Node, NodesCollection } from "@flyde/core/";
    import { ExecuteParams } from "@flyde/core/execute";
    export const simplifiedExecute: (nodeToRun: Node, resolvedDependencies: NodesCollection, inputs?: Record<string, any>, onOutput?: (key: string, data: any) => void, otherParams?: Partial<ExecuteParams>) => import("./execute").CancelFn;
}

declare module '@flyde/core/node/get-node-with-dependencies' {
    import { CustomNodeCollection, VisualNode } from "@flyde/core/";
    export const getNodeWithDependencies: (node: VisualNode, resolvedDeps: CustomNodeCollection, existingIds?: string[]) => VisualNode[];
}

declare module '@flyde/core/types/connections' {
    import { THIS_INS_ID } from "@flyde/core/connect/helpers";
    export type ConnectionData = {
        from: ConnectionNode;
        to: ConnectionNode;
        delayed?: boolean;
        hidden?: boolean;
    };
    export type ExternalConnectionNode = {
        insId: typeof THIS_INS_ID;
        pinId: string;
    };
    export type InternalConnectionNode = {
        insId: string;
        pinId: string;
    };
    export type ConnectionNode = ExternalConnectionNode | InternalConnectionNode;
}

declare module '@flyde/core/improved-macros/improved-macros' {
    import { InternalCodeNode, InputPin, OutputPin, InternalMacroNode, NodeStyle, InputMode } from "@flyde/core/";
    export * from "@flyde/core/improved-macros/improved-macro-utils";
    export type StaticOrDerived<T, Config> = T | ((config: Config) => T);
    export interface BaseMacroNodeData<Config = any> {
            mode?: "simple" | "advanced";
            id: string;
            namespace?: string;
            menuDisplayName?: string;
            menuDescription?: string;
            displayName?: StaticOrDerived<string, Config>;
            description?: StaticOrDerived<string, Config>;
            overrideNodeBodyHtml?: StaticOrDerived<string, Config>;
            aliases?: string[];
            icon?: string;
            completionOutputs?: StaticOrDerived<string[], Config>;
            run: InternalCodeNode["run"];
    }
    export interface SimplifiedMacroNode<Config> extends BaseMacroNodeData<Config> {
            inputs: Record<string, InputConfig>;
            outputs: Record<string, {
                    description?: string;
            }>;
    }
    export interface AdvancedMacroNode<Config> extends BaseMacroNodeData<Config> {
            mode: "advanced";
            inputs: StaticOrDerived<Record<string, InputPin>, Config>;
            outputs: StaticOrDerived<Record<string, OutputPin>, Config>;
            reactiveInputs?: StaticOrDerived<string[], Config>;
            defaultConfig: Config;
            editorConfig?: InternalMacroNode<Config>["editorConfig"];
            defaultStyle?: NodeStyle;
    }
    export type CodeNode<Config = any> = SimplifiedMacroNode<Config> | AdvancedMacroNode<Config>;
    export type InputConfig = {
            defaultValue?: any;
            /**
                * The label displayed above the input field.
                * If not provided, the description will be used as the label.
                * @recommended
                */
            label?: string;
            description?: string;
            mode?: InputMode | "reactive";
            /**
                * Whether the type of this input can be changed in the editor.
                * When false, the "Change type" button will not be shown and the input won't be exposed as an input pin.
                * @default true
                */
            typeConfigurable?: boolean;
            aiCompletion?: {
                    prompt: string;
                    placeholder?: string;
                    jsonMode?: boolean;
            };
            /**
                * Optional condition that determines whether this input should be shown.
                * If the condition evaluates to false, the input will be hidden.
                *
                * Uses a string expression like "method !== 'GET'" that will be evaluated against the config.
                * The expression can reference other field values directly by their key.
                *
                * @example
                * condition: "method !== 'GET'"
                */
            condition?: string;
            /**
                * Optional group configuration for organizing inputs.
                * When specified, this input will be treated as a group container.
                */
            group?: {
                    /**
                        * The title of the group
                        */
                    title: string;
                    /**
                        * Whether the group is collapsible
                        */
                    collapsible?: boolean;
                    /**
                        * Whether the group is collapsed by default (only applies if collapsible is true)
                        */
                    defaultCollapsed?: boolean;
                    /**
                        * Fields to include in this group.
                        * Can include both regular field keys and other group keys for nested groups.
                        */
                    fields: string[];
                    /**
                        * Optional parent group key. When specified, this group will be nested inside the parent group.
                        * If not specified, the group will be at the top level.
                        */
                    parentGroup?: string;
            };
    } & EditorTypeConfig;
    type EditorTypeConfig = {
            [K in EditorType]: {
                    editorType?: K;
                    editorTypeData?: EditorTypeDataMap[K];
            };
    }[EditorType];
    type EditorType = "string" | "number" | "boolean" | "json" | "select" | "longtext" | "enum";
    type EditorTypeDataMap = {
            string: undefined;
            number: {
                    min?: number;
                    max?: number;
            };
            boolean: undefined;
            json: undefined;
            select: {
                    options: string[] | {
                            value: string | number;
                            label: string;
                    }[];
            };
            longtext: {
                    rows?: number;
            };
            enum: {
                    options: string[];
            };
    };
    export function isAdvancedMacroNode<Config>(node: CodeNode<Config>): node is AdvancedMacroNode<Config>;
    export function isSimplifiedMacroNode<Config>(node: CodeNode<Config>): node is SimplifiedMacroNode<Config>;
    export function isCodeNode<Config>(node: any): node is CodeNode<Config>;
    export function processImprovedMacro(node: CodeNode): InternalMacroNode<any>;
}

declare module '@flyde/core/improved-macros/improved-macro-utils' {
    import { InputPin, MacroConfigurableValue, MacroEditorFieldDefinition, InternalMacroNode, InputMode } from "@flyde/core/";
    import { InputConfig } from "@flyde/core/improved-macros/improved-macros";
    export function extractInputsFromValue(val: MacroConfigurableValue, key: string, mode?: InputMode): Record<string, InputPin>;
    export function replaceInputsInValue(inputs: Record<string, any>, value: MacroConfigurableValue, fieldName: string, ignoreMissingInputs?: boolean): MacroConfigurableValue["value"];
    export function renderConfigurableValue(value: MacroConfigurableValue, fieldName: string): string;
    export function generateConfigEditor<Config>(config: Config, overrides?: Partial<Record<keyof Config, any>>): InternalMacroNode<Config>["editorConfig"];
    export function renderDerivedString(displayName: string, config: any): string;
    /**
        * Evaluates a string condition against a configuration object.
        *
        * @param condition The string expression to evaluate
        * @param config The configuration object to evaluate against
        * @returns True if the condition is met, false otherwise
        */
    export function evaluateCondition(condition: string | undefined, config: Record<string, any>): boolean;
    /**
        * Evaluates whether a field in a group hierarchy should be visible.
        * A field is visible only if all its parent groups are visible.
        *
        * @param field The field to check visibility for
        * @param fieldPath Array of parent group field IDs leading to this field
        * @param allFields Map of all fields by their ID
        * @param config The configuration object to evaluate conditions against
        * @returns True if the field should be visible, false otherwise
        */
    export function evaluateFieldVisibility(fieldKey: string, groupHierarchy: string[], allFields: Record<string, MacroEditorFieldDefinition>, config: Record<string, any>): boolean;
    /**
        * Creates a group configuration for use in InputConfig.
        *
        * @param title The title of the group
        * @param fields Array of field keys to include in the group
        * @param options Additional group options
        * @returns A group configuration object
        */
    export function createInputGroup(title: string, fields: string[], options?: {
            collapsible?: boolean;
            defaultCollapsed?: boolean;
            parentGroup?: string;
            condition?: string;
    }): NonNullable<InputConfig["group"]> & {
            condition?: string;
    };
}

declare module '@flyde/core/common/test-data-creator' {
    export type TestDataCreator<T> = (partial?: Partial<T>) => T;
    export type ObjOrObjCreator<T> = T | (() => T);
    export const testDataCreator: <T extends object>(defaults: ObjOrObjCreator<T>) => TestDataCreator<T>;
}

declare module '@flyde/core/common/utils' {
    export type Pos = {
        x: number;
        y: number;
    };
    export interface OMap<T> {
        [k: string]: T | undefined;
    }
    export interface OMapF<T> {
        [k: string]: T;
    }
    export type Rect = Pos & {
        w: number;
        h: number;
    };
    export const intersectRect: (r1: Rect, r2: Rect) => boolean;
    export const calcCenter: ({ w, h, x, y }: Rect) => Pos;
    export const middlePos: (p1: Pos, p2: Pos) => Pos;
    export const mapOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => T) => OMap<T>;
    export const filterOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => boolean) => OMap<T>;
    export const keys: <V>(map: OMap<V>) => string[];
    export const values: <V>(map: OMap<V>) => V[];
    export const entries: <V>(map: OMap<V>) => Array<[string, V]>;
    export const fromEntries: <V>(entries: Array<[string, V]>) => OMap<V>;
    export const pickFirst: <K>(v: [K, any]) => K;
    export const pickSecond: <K>(v: [any, K]) => K;
    export type RandomFunction = {
        (): number;
        (max: number): number;
        (max: number, min: number): number;
    };
    export const randomInt: RandomFunction;
    export const randomPos: (to?: number, from?: number) => Pos;
    export const pickRandom: <K>(v: K[]) => K;
    export const repeat: <T>(count: number, run: (idx: number) => T) => T[];
    export const randomInts: (count: number, to?: number, from?: number) => number[];
    export const shuffle: (arr: any[]) => any[];
    export const containsAll: <T>(arr: T[], items: T[]) => boolean;
    export const isDefined: <T>(o: T) => o is NonNullable<T>;
    export const isPromise: <T>(o: any) => o is Promise<T>;
    export const callFnOrFnPromise: (maybeFnOrFnPromise: void | Function | Promise<void | Function>, errorMsg: string) => void;
    export const isOptionalType: (type: string) => boolean;
    export const ensure: <T>(v: T, msg?: string) => NonNullable<T>;
    export const removeDupes: (list: string[]) => string[];
    export const noop: () => void;
    export const delay: (ms: number) => Promise<unknown>;
    export const eventually: (callback: () => void, timeout?: number, retryDelay?: number, errorSet?: Set<string>) => Promise<void>;
    export function simplePluralize(count: number, noun: string): string;
}

declare module '@flyde/core/common/debug-logger' {
    import type { Debugger as _Debugger } from "debug";
    export type DebugLogger = _Debugger;
    export const debugLogger: (subNs: string) => DebugLogger;
}

declare module '@flyde/core/common/capped-array-debounce' {
    export const cappedArrayDebounce: <T>(cb: (items: T[]) => void, timeout: number, maxItems: number, maxTimeWaiting?: number) => {
        addItem: (item: T) => void;
        flush: () => void;
        pendingItems: () => number;
    };
}

declare module '@flyde/core/common/hasher' {
    import { FlydeFlow } from "@flyde/core/flow-schema";
    import { Node } from "@flyde/core/node";
    export const hashNode: (node: Node, ignorePos?: boolean) => string;
    export const hashFlow: (flow: FlydeFlow) => string;
}

declare module '@flyde/core/common/value-builders' {
    import { OMap } from "@flyde/core/common";
    export const compileStringTemplate: (template: string, inputs: OMap<any>) => string;
    export const compileObjectTemplate: (template: string, inputs: OMap<any>) => any;
}

declare module '@flyde/core/common/data-shaper' {
    export enum DataShapeType {
        STRING = 0,
        NUMBER = 1,
        BOOLEAN = 2,
        ARRAY = 3,
        OBJECT = 4,
        NULL = 5,
        UNSUPPORTED = 6
    }
    export type DataShaperOptions = {
        maxDepth: number;
        maxArrayCheckIdx: number;
    };
    export type DataShape = DataShapeType | DataShape[] | {
        [key: string]: DataShape;
    };
    export const dataShaper: (data: any, maxDepth?: number, maxArrayCheckIdx?: number) => DataShape;
}

declare module '@flyde/core/common/full-ins-id-path' {
    export function fullInsIdPath(insId: string, ancestorsInsIds?: string): string;
}

declare module '@flyde/core/node/node-instance' {
    import { InternalCodeNode, InputPinsConfig, Node, NodeDefinition, NodeStyle, Pos, ResolvedVisualNode, VisualNode } from "@flyde/core/";
    export interface NodeInstanceConfig {
        inputConfig: InputPinsConfig;
        visibleInputs?: string[];
        visibleOutputs?: string[];
        displayName?: string;
        style?: NodeStyle;
        id: string;
        pos: Pos;
    }
    export interface RefNodeInstance extends NodeInstanceConfig {
        nodeId: string;
    }
    export interface InlineNodeInstance extends NodeInstanceConfig {
        node: VisualNode | InternalCodeNode;
    }
    export interface ResolvedInlineNodeInstance extends NodeInstanceConfig {
        node: ResolvedVisualNode | InternalCodeNode;
    }
    export interface MacroNodeInstance extends NodeInstanceConfig {
        macroId: string;
        macroData: any;
    }
    export interface ResolvedMacroNodeInstance extends NodeInstanceConfig {
        nodeId: string;
        macroId: string;
        macroData: any;
    }
    export type NodeInstance = RefNodeInstance | InlineNodeInstance | MacroNodeInstance;
    export type ResolvedNodeInstance = RefNodeInstance | ResolvedInlineNodeInstance | ResolvedMacroNodeInstance;
    export const nodeInstance: (id: string, nodeOrId: string, config?: InputPinsConfig, pos?: Pos) => NodeInstance;
    export const inlineNodeInstance: (insId: string, node: Node, config?: InputPinsConfig, pos?: Pos) => NodeInstance;
    export const macroNodeInstance: (id: string, macroId: string, macroData: any, config?: InputPinsConfig, pos?: Pos) => ResolvedMacroNodeInstance;
    export const isInlineNodeInstance: (ins: NodeInstance) => ins is InlineNodeInstance;
    export const isRefNodeInstance: (ins: NodeInstance) => ins is RefNodeInstance;
    export const isMacroNodeInstance: (ins: NodeInstance) => ins is MacroNodeInstance;
    export const isResolvedMacroNodeInstance: (ins: ResolvedNodeInstance | NodeInstance) => ins is ResolvedMacroNodeInstance;
    export const NodeInstance: (id: string, node: NodeDefinition, config?: InputPinsConfig, pos?: Pos) => NodeInstance;
    export const createInsId: (node: NodeDefinition) => string;
}

declare module '@flyde/core/node/node-pins' {
    import { Subject } from "rxjs";
    import { OMapF } from "@flyde/core/";
    import { QueueInputPinConfig, StickyInputPinConfig } from "@flyde/core/node/pin-config";
    export type PinType = "input" | "output";
    export type InputMode = "optional" | "required" | "required-if-connected";
    export interface BasePinData {
        description?: string;
    }
    export interface InputPin extends BasePinData {
        mode?: InputMode;
    }
    export type InputPinMap = Record<string, InputPin>;
    export type OutputPinMap = Record<string, OutputPin>;
    export interface OutputPin extends BasePinData {
        delayed?: boolean;
    }
    export const nodeInput: (mode?: InputMode) => InputPin;
    export const isInputPinOptional: (input: InputPin) => boolean;
    export const nodeInputs: (count: number, modes?: InputMode[]) => InputPin[];
    export const nodeOutput: (delayed?: boolean) => OutputPin;
    export const nodeOutputs: (count: number) => OutputPin[];
    export type DynamicNodeInput = {
        subject: Subject<any>;
        config: StickyInputPinConfig | QueueInputPinConfig;
    };
    export type NodeInput = DynamicNodeInput;
    export type NodeOutput = Subject<any>;
    export type NodeOutputs = OMapF<NodeOutput>;
    export type NodeInputs = OMapF<NodeInput>;
    export interface DynamicOutput extends Subject<any> {
    }
    export const dynamicOutput: () => DynamicOutput;
    export const dynamicNodeInput: import("..").TestDataCreator<DynamicNodeInput>;
    export const dynamicNodeInputs: (count?: number) => DynamicNodeInput[];
}

declare module '@flyde/core/node/pin-config' {
    import { OMap } from "@flyde/core/";
    export type QueueInputPinConfig = {
        mode: "queue";
    };
    export type StickyInputPinConfig = {
        mode: "sticky";
    };
    export type InputPinConfig = QueueInputPinConfig | StickyInputPinConfig;
    export type InputPinsConfig = OMap<InputPinConfig>;
    export const queueInputPinConfig: () => QueueInputPinConfig;
    export const stickyInputPinConfig: () => StickyInputPinConfig;
    export const isQueueInputPinConfig: (config: InputPinConfig | undefined) => config is QueueInputPinConfig;
    export const isStickyInputPinConfig: (config: InputPinConfig | undefined) => config is StickyInputPinConfig;
}

declare module '@flyde/core/node/nodeFromSimpleFunction' {
    import { BaseNode, InternalCodeNode, NodeStyleSize, RunNodeFunction } from "@flyde/core/node";
    import { InputMode } from "@flyde/core/node/node-pins";
    export type SimpleFnData = Omit<BaseNode, "inputs" | "outputs" | "run"> & {
        id: string;
        description: string;
        namespace: string;
        inputs?: {
            name: string;
            description: string;
            mode?: InputMode;
            defaultValue?: any;
        }[];
        output?: {
            name: string;
            description: string;
        };
        run?: (...args: any[]) => any;
        symbol?: string;
        icon?: string;
        size?: NodeStyleSize;
        fullRunFn?: RunNodeFunction;
    };
    export function nodeFromSimpleFunction(data: SimpleFnData): InternalCodeNode;
}

declare module '@flyde/core/node/node-instance-error' {
    export class NodeInstanceError extends Error {
        fullInsIdsPath: string;
        nodeId: string;
        constructor(error: unknown, fullInsIdsPath: string, nodeId: string);
    }
}

declare module '@flyde/core/node/node' {
    import { OMap, OMapF, Pos } from "@flyde/core/common";
    import { Subject } from "rxjs";
    import { CancelFn, InnerExecuteFn } from "@flyde/core/execute";
    import { NodeInstance, ResolvedNodeInstance } from "@flyde/core/node/node-instance";
    import { InputPin, OutputPin } from "@flyde/core/node/node-pins";
    import { ImportedNode } from "@flyde/core/flow-schema";
    import { MacroNodeDefinition } from "@flyde/core/node/macro-node";
    import { CodeNode } from "@flyde/core/";
    import { ConnectionData } from "@flyde/core/types/connections";
    export type NodesCollection = OMap<Node | CodeNode>;
    export type NodesDefCollection = OMap<NodeDefinition>;
    export type CustomNodeCollection = OMap<VisualNode>;
    export type NodeState = Map<string, any>;
    export type NodeAdvancedContext = {
            execute: InnerExecuteFn;
            insId: string;
            ancestorsInsIds?: string;
            state: NodeState;
            globalState: NodeState;
            onCleanup: (cb: Function) => void;
            onError: (e: any) => void;
            context: Record<string, any>;
    };
    export type RunNodeFunction = (args: OMapF<any>, o: OMapF<Subject<any>>, adv: NodeAdvancedContext) => void | CancelFn | Promise<void | CancelFn>;
    export type CustomNodeViewFn = (instance: NodeInstance, inputs: OMap<NodeInstance[]>, outputs: OMap<NodeInstance[]>, resolvedDeps: NodesDefCollection) => {
            label: string;
            hiddenInputs?: string[];
            hiddenOutputs?: string[];
    } | false;
    export type NodeStyleSize = "small" | "regular" | "large";
    export type NodeTypeIcon = string | [string, string];
    export interface NodeStyle {
            icon?: NodeTypeIcon;
            size?: NodeStyleSize;
            color?: string | [string, string];
            cssOverride?: Record<string, string>;
    }
    export interface NodeMetadata {
            /**
                * Node's unique id. {@link VisualNode.instances }  refer use this to refer to the correct node
                */
            id: string;
            /**
                * A human readable name for the node. Used in the visual editor.
                */
            displayName?: string;
            menuDisplayName?: string;
            /**
                * Is displayed in the visual editor and used to search for nodes.
                */
            description?: string;
            /**
                * A list of keywords that can be used to search for the node. Useful for node that users might search using different words.
                */
            aliases?: string[];
            /**
                * TBD
                */
            namespace?: string;
            icon?: string;
            /**
                * All instances of this node will inherit the default style if it is supplied.
                * See {@link NodeStyle} for the full options supported
                */
            defaultStyle?: NodeStyle;
            /**
                * Hack to support note node without adding first class support for it.
                * This is used to override the node body html for a node.
                */
            overrideNodeBodyHtml?: string;
    }
    /**
        * Extended by {@link VisualNode}, {@link InternalCodeNode} and {@link InlineValueNode}
        */
    export interface BaseNode extends NodeMetadata {
            /**
                * A pin on a node that receives data. Each node can have zero or more input pins.
                *
                * Example for the inputs of a mathematical multiplier node:
                * \`\`\`ts
                * {
                *  multiplicand: { description: "The number to be multiplied" },
                *  multiplier: { description: "The number with which we multiply" },
                * }
                * \`\`\`
                */
            inputs: Record<string, InputPin>;
            /**
                * A pin on a node that sends data. Each node can have zero or more output pins.
                * For example, a "Split array" node might have one input pin for an array and two output pins for the first and second halves of the array:
                *
                * @example
                * \`\`\`ts
                * {
                *  'first half': { description: "The first half of the array" },
                *  'second half': { description: "The second half of the array" },
                * }
                * \`\`\`
                */
            outputs: Record<string, OutputPin>;
            /**
                * Instructs Flyde that the node is in "explicit completion" mode and describes which outputs trigger the node's completion. Receives a list of outputs that should trigger an explicit completion of the node when they emit a value. Any of the listed outputs will trigger a completion (i.e. completionOutput[0] \`OR\` completionOutput[1])
                * Leave empty for implicit completion. This should work best for 99% of the case.
                *
                * To declare that 2 different outputs must emit a value in order to trigger a completion, different outputs can be joined together with a \`+\` sign as following:
                * \`\`\` ts
                * {
                * ...
                *  completionOutputs: ["data+headers", "error"] // this means either data AND headers, OR "error" will trigger an explicit completion.
                * \`\`\`
                *
                * See the [Nodes lifecycle](/docs/lifecycle) for more info
                */
            completionOutputs?: string[];
            /**
                * @deprecated - TBD
                */
            reactiveInputs?: string[];
    }
    export interface InternalCodeNode extends BaseNode {
            /**
                * This function will run as soon as the node's inputs are satisfied.
                * It has access to the nodes inputs values, and output pins. See {@link RunNodeFunction} for more information.
                *
                */
            run: RunNodeFunction;
            /**
                * @deprecated use {@link InternalCodeNode['run']} instead
                */
            fn?: RunNodeFunction;
    }
    export * from "@flyde/core/node/macro-node";
    /**
        * A visual node is what makes Flyde special. It represents a node created visually in the editor.
        * It consists of node instances and connections. Each node instance will either refer to an imported node (by id), or include the node "inline".
        * Each connection will represent a "wire" between 2 instances, or between an instance and a main input/output pin.
        * Connecting to a main input or output is the way that a visual nodes' internal implementation can communicate with its external API.
        */
    export interface VisualNode extends BaseNode {
            /** a map holding the position for each main input. Used in the editor only. */
            inputsPosition: OMap<Pos>;
            /** a map holding the position for each main output. Used in the editor only. */
            outputsPosition: OMap<Pos>;
            /** the visual nodes internal node instances, either referring to other nodes by id or by value (inline) */
            instances: NodeInstance[];
            /** each connection represents a "wire" between 2 different instances, or between an instance and a main input/output*/
            connections: ConnectionData[];
            /** TODO - either deprecate this or {@link BaseNode.customViewCode} */
            customView?: CustomNodeViewFn;
    }
    export interface ResolvedVisualNode extends VisualNode {
            instances: ResolvedNodeInstance[];
    }
    export type Node = InternalCodeNode | VisualNode;
    export type ImportableSource = {
            module: string;
            node: ImportedNode;
    };
    export type CodeNodeDefinition = Omit<InternalCodeNode, "run"> & {
            /**
                * The source code of the node, if available. Used for editing and forking nodes in the editor.
                */
            sourceCode?: string;
    };
    export type NodeDefinition = VisualNode | CodeNodeDefinition;
    export type NodeOrMacroDefinition = NodeDefinition | MacroNodeDefinition<any>;
    export type NodeModuleMetaData = {
            imported?: boolean;
    };
    export type NodeDefinitionWithModuleMetaData = NodeDefinition & NodeModuleMetaData;
    export const isBaseNode: (p: any) => p is BaseNode;
    export const extractMetadata: <N extends NodeMetadata>(node: N) => NodeMetadata;
    export const isVisualNode: (p: Node | NodeDefinition) => p is VisualNode;
    export const visualNode: import("..").TestDataCreator<VisualNode>;
    export const InternalCodeNode: import("..").TestDataCreator<InternalCodeNode>;
    export type SimplifiedNodeParams = {
            id: string;
            inputTypes: OMap<string>;
            outputTypes: OMap<string>;
            run: RunNodeFunction;
    };
    export const fromSimplified: ({ run, inputTypes, outputTypes, id, }: SimplifiedNodeParams) => InternalCodeNode;
    export const getNode: (idOrIns: string | NodeInstance, resolvedNodes: NodesCollection) => Node;
    export const getNodeDef: (idOrIns: string | NodeInstance, resolvedNodes: NodesDefCollection) => NodeDefinition;
    export type codeFromFunctionParams = {
            id: string;
            fn: Function;
            inputNames: string[];
            outputName: string;
            defaultStyle?: NodeStyle;
    };
    export const codeFromFunction: ({ id, fn, inputNames, outputName, defaultStyle, }: codeFromFunctionParams) => InternalCodeNode;
}

declare module '@flyde/core/execute/debugger' {
    import { DebuggerEvent } from "@flyde/core/execute/debugger/events";
    export * from "@flyde/core/execute/debugger/events";
    export * from "@flyde/core/execute/debugger/format-event";
    export type DebuggerInterceptCommand = {
        cmd: "intercept";
        valuePromise: Promise<any>;
    };
    export type DebuggerCommand = DebuggerInterceptCommand | void;
    export type Debugger = {
        onEvent?: <T extends DebuggerEvent>(event: Omit<T, "time" | "executionId">) => DebuggerCommand;
        debugDelay?: number;
        destroy?: () => void;
    };
}

declare module '@flyde/core/' {
    export * from "@flyde/core/common";
    import { Pos, OMap } from "@flyde/core/common";
    import { FlydeFlow } from "@flyde/core/flow-schema";
    import { VisualNode, InputPinsConfig, NodeDefinition, NodeOrMacroDefinition, MacroNodeDefinition } from "@flyde/core/node";
    export * from "@flyde/core/connect/helpers";
    export * from "@flyde/core/execute";
    export * from "@flyde/core/simplified-execute";
    export * from "@flyde/core/node";
    export * from "@flyde/core/node/get-node-with-dependencies";
    export * from "@flyde/core/flow-schema";
    export * from "@flyde/core/types/connections";
    export * from "@flyde/core/improved-macros/improved-macros";
    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from "@flyde/core/improved-macros/improved-macro-utils";
    export interface InstanceViewData {
        id: string;
        nodeIdOrGroup: string | VisualNode;
        pos: Pos;
        visibleOptionalInputs?: string[];
        inputConfig: InputPinsConfig;
    }
    export type NodesDefCollection = OMap<NodeDefinition>;
    export type MacrosDefCollection = OMap<MacroNodeDefinition<any>>;
    export interface NodeLibraryGroup {
        title: string;
        nodes: NodeOrMacroDefinition[];
    }
    export interface NodeLibraryData {
        groups: NodeLibraryGroup[];
    }
    export type ImportablesResult = {
        importables: Record<string, NodesDefCollection>;
        errors: {
            path: string;
            message: string;
        }[];
    };
    export type ImportableMacrosResult = {
        importableMacros: Record<string, MacrosDefCollection>;
        errors: {
            path: string;
            message: string;
        }[];
    };
    export interface FlowJob {
        flow: FlydeFlow;
        id: string;
    }
}

declare module '@flyde/core/node/macro-node' {
    import { InternalCodeNode, CodeNodeDefinition, NodeMetadata } from "@flyde/core/node/node";
    import type React from "react";
    import { MacroNodeInstance } from "@flyde/core/node/node-instance";
    export function macroConfigurableValue(type: MacroConfigurableValue["type"], value: MacroConfigurableValue["value"]): MacroConfigurableValue;
    import { CodeNode } from "@flyde/core/improved-macros/improved-macros";
    export type MacroEditorFieldDefinitionType = "string" | "number" | "boolean" | "json" | "select" | "longtext" | "dynamic";
    export type MacroConfigurableValueTypeMap = {
            string: string;
            number: number;
            boolean: boolean;
            json: any;
            select: string | number;
            dynamic: undefined;
    };
    export type MacroConfigurableValue = {
            [K in keyof MacroConfigurableValueTypeMap]: {
                    type: K;
                    value: MacroConfigurableValueTypeMap[K];
            };
    }[keyof MacroConfigurableValueTypeMap];
    export type MacroEditorFieldDefinition = StringFieldDefinition | NumberFieldDefinition | BooleanFieldDefinition | JsonFieldDefinition | SelectFieldDefinition | LongTextFieldDefinition | GroupFieldDefinition;
    interface BaseFieldDefinition {
            label: string;
            description?: string;
            configKey: string;
            templateSupport?: boolean;
            typeConfigurable?: boolean;
            aiCompletion?: {
                    prompt: string;
                    placeholder?: string;
                    jsonMode?: boolean;
            };
            /**
                * Optional condition that determines whether this field should be shown.
                * If the condition evaluates to false, the field will be hidden.
                *
                * Uses a string expression like "method !== 'GET'" that will be evaluated against the values.
                * The expression can reference other field values directly by their key.
                *
                * @example
                * condition: "method === 'POST'"
                */
            condition?: string;
    }
    export interface StringFieldDefinition extends BaseFieldDefinition {
            type: "string";
    }
    export interface BooleanFieldDefinition extends BaseFieldDefinition {
            type: "boolean";
    }
    export interface JsonFieldDefinition extends BaseFieldDefinition {
            type: "json";
            typeData?: {
                    helperText?: string;
            };
    }
    export interface LongTextFieldDefinition extends BaseFieldDefinition {
            type: "longtext";
            typeData?: {
                    rows?: number;
            };
    }
    export interface NumberFieldDefinition extends BaseFieldDefinition {
            type: "number";
            typeData?: NumberTypeData;
    }
    export interface SelectFieldDefinition extends BaseFieldDefinition {
            type: "select";
            typeData: SelectTypeData;
    }
    export interface NumberTypeData {
            min?: number;
            max?: number;
    }
    export interface SelectTypeData {
            options: {
                    value: string | number;
                    label: string;
            }[];
    }
    export interface MacroEditorConfigCustomResolved {
            type: "custom";
            editorComponentBundlePath: string;
    }
    export interface MacroEditorConfigCustomDefinition {
            type: "custom";
            editorComponentBundleContent: string;
    }
    export interface MacroEditorConfigStructured {
            type: "structured";
            fields: MacroEditorFieldDefinition[];
    }
    export type MacroEditorConfigResolved = MacroEditorConfigCustomResolved | MacroEditorConfigStructured;
    export type MacroEditorConfigDefinition = MacroEditorConfigCustomDefinition | MacroEditorConfigStructured;
    export interface InternalMacroNode<T = any> extends NodeMetadata {
            definitionBuilder: (data: T) => Omit<CodeNodeDefinition, "id" | "namespace">;
            runFnBuilder: (data: T) => InternalCodeNode["run"];
            defaultData: T;
            /**
                * Assumes you are bundling the editor component using webpack library+window config.
                * The name of the window variable that holds the component should be __MacroNode__{id}
                * The path should be relative to the root of the project (package.json location)
                */
            editorConfig: MacroEditorConfigResolved;
    }
    export type MacroNodeDefinition<T> = Omit<InternalMacroNode<T>, "definitionBuilder" | "runFnBuilder" | "editorComponentBundlePath" | "editorConfig"> & {
            /**
                * Resolver will use this to load the editor component bundle into the editor
                */
            editorConfig: MacroEditorConfigDefinition;
            sourceCode?: string;
    };
    export interface MacroEditorCompProps<T> {
            value: T;
            onChange: (value: T) => void;
            prompt: (message: string) => Promise<string>;
            createAiCompletion?: (prompt: {
                    prompt: string;
                    currentValue?: any;
            }) => Promise<string>;
    }
    export interface MacroEditorComp<T> extends React.FC<MacroEditorCompProps<T>> {
    }
    export const isInternalMacroNode: (p: any) => p is InternalMacroNode<any>;
    export const isMacroNodeDefinition: (p: any) => p is MacroNodeDefinition<any>;
    export function processMacroNodeInstance(prefix: string, _macro: InternalMacroNode<any> | CodeNode, instance: MacroNodeInstance): InternalCodeNode;
    export interface GroupFieldDefinition extends BaseFieldDefinition {
            type: "group";
            fields: MacroEditorFieldDefinition[];
            typeData?: {
                    /**
                        * Whether the group is collapsible
                        */
                    collapsible?: boolean;
                    /**
                        * Whether the group is collapsed by default (only applies if collapsible is true)
                        */
                    defaultCollapsed?: boolean;
            };
    }
    export {};
}

declare module '@flyde/core/execute/debugger/events' {
    import { OMap } from "@flyde/core/";
    export enum DebuggerEventType {
        INPUT_CHANGE = "i",
        OUTPUT_CHANGE = "o",
        PROCESSING_CHANGE = "pc",
        ERROR = "err",
        INPUTS_STATE_CHANGE = "isc"
    }
    export const MAJOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];
    export const MINOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];
    export type BaseDebuggerEvent<T extends DebuggerEventType> = {
        type: T;
        insId: string;
        ancestorsInsIds?: string;
        nodeId: string;
        val: DebuggerEventTypeData[T];
        time: number;
        executionId: string;
    };
    export type PinDebuggerEvent<T extends DebuggerEventType> = {
        pinId: string;
    } & BaseDebuggerEvent<T>;
    export type DebuggerEventTypeData = {
        [DebuggerEventType.INPUTS_STATE_CHANGE]: OMap<number>;
        [DebuggerEventType.PROCESSING_CHANGE]: boolean;
        [DebuggerEventType.ERROR]: any;
        [DebuggerEventType.INPUT_CHANGE]: string;
        [DebuggerEventType.OUTPUT_CHANGE]: string;
    };
    export type MajorDebuggerEvent = PinDebuggerEvent<DebuggerEventType.OUTPUT_CHANGE> | PinDebuggerEvent<DebuggerEventType.INPUT_CHANGE> | BaseDebuggerEvent<DebuggerEventType.ERROR>;
    export type MinorDebuggerEvent = BaseDebuggerEvent<DebuggerEventType.INPUTS_STATE_CHANGE> | BaseDebuggerEvent<DebuggerEventType.PROCESSING_CHANGE>;
    export type DebuggerEvent = MajorDebuggerEvent | MinorDebuggerEvent;
}

declare module '@flyde/core/execute/debugger/format-event' {
    import { DebuggerEvent } from "@flyde/core/execute/debugger/events";
    export function formatEvent(event: DebuggerEvent): string;
}

`;
