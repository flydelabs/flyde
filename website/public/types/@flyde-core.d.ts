// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../dependency-graph
//   ../../../../zod
//   ../../../../rxjs
//   ../../../../debug
//   ../../../../react

declare module '@flyde/core' {
    export * from "@flyde/core/common";
    import { Pos } from "@flyde/core/common";
    import { FlydeFlow } from "@flyde/core/flow-schema";
    import { VisualNode, InputPinsConfig } from "@flyde/core/node";
    export * from "@flyde/core/connect/helpers";
    export * from "@flyde/core/execute";
    export * from "@flyde/core/simplified-execute";
    export * from "@flyde/core/node";
    export * from "@flyde/core/flow-schema";
    export * from "@flyde/core/types/connections";
    export * from "@flyde/core/types/editor";
    export * from "@flyde/core/configurable-nodes/configurable-nodes";
    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from "@flyde/core/configurable-nodes/configurable-node-utils";
    export * from "@flyde/core/remote-debugger";
    export * from "@flyde/core/run-node";
    export interface InstanceViewData {
        id: string;
        nodeIdOrGroup: string | VisualNode;
        pos: Pos;
        visibleOptionalInputs?: string[];
        inputConfig: InputPinsConfig;
    }
    export interface FlowJob {
        flow: FlydeFlow;
        id: string;
    }
    export * from "@flyde/core/telemetry";
}

declare module '@flyde/core/common' {
    export * from "@flyde/core/common/test-data-creator";
    export * from "@flyde/core/common/utils";
    export * from "@flyde/core/common/debug-logger";
    export * from "@flyde/core/common/capped-array-debounce";
    export * from "@flyde/core/common/utils";
    export * from "@flyde/core/common/value-builders";
    export * from "@flyde/core/common/data-shaper";
    export * from "@flyde/core/common/full-ins-id-path";
    import { DepGraph as _DepGraph } from "dependency-graph";
    export const DepGraph: typeof _DepGraph;
}

declare module '@flyde/core/flow-schema' {
    import { z } from "zod";
    import { VisualNode, NodeDefinition } from "@flyde/core/node";
    import { CodeNode } from "@flyde/core/configurable-nodes/configurable-nodes";
    export type FlydeFlow = {
        /** @deprecated */
        imports?: Record<string, string[]>;
        node: VisualNode;
    };
    export type ImportedNodeDefinition = NodeDefinition;
    export type ImportedNode = VisualNode | CodeNode;
    export type ImportedNodeDef = NodeDefinition;
    export const flydeFlowSchema: z.ZodObject<{
        /** @deprecated */
        imports: z.ZodDefault<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>>>>;
        node: z.ZodIntersection<z.ZodObject<{
            instances: z.ZodArray<z.ZodObject<{
                pos: z.ZodDefault<z.ZodObject<{
                    x: z.ZodNumber;
                    y: z.ZodNumber;
                }, "strict", z.ZodTypeAny, {
                    x?: number;
                    y?: number;
                }, {
                    x?: number;
                    y?: number;
                }>>;
                id: z.ZodString;
                inputConfig: z.ZodDefault<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodDiscriminatedUnion<"mode", [z.ZodObject<{
                    mode: z.ZodLiteral<"queue">;
                }, "strict", z.ZodTypeAny, {
                    mode?: "queue";
                }, {
                    mode?: "queue";
                }>, z.ZodObject<{
                    mode: z.ZodLiteral<"sticky">;
                }, "strict", z.ZodTypeAny, {
                    mode?: "sticky";
                }, {
                    mode?: "sticky";
                }>]>>>>;
                visibleInputs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
                visibleOutputs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
                displayName: z.ZodOptional<z.ZodString>;
                nodeId: z.ZodOptional<z.ZodString>;
                macroId: z.ZodOptional<z.ZodString>;
                macroData: z.ZodOptional<z.ZodAny>;
                config: z.ZodOptional<z.ZodAny>;
                node: z.ZodOptional<z.ZodAny>;
                type: z.ZodOptional<z.ZodEnum<["code", "visual"]>>;
                source: z.ZodOptional<z.ZodObject<{
                    type: z.ZodString;
                    data: z.ZodAny;
                }, "strip", z.ZodTypeAny, {
                    type?: string;
                    data?: any;
                }, {
                    type?: string;
                    data?: any;
                }>>;
                style: z.ZodOptional<z.ZodObject<{
                    size: z.ZodOptional<z.ZodEnum<["small", "regular", "large"]>>;
                    icon: z.ZodOptional<z.ZodAny>;
                    color: z.ZodOptional<z.ZodString>;
                    cssOverride: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
                }, "strip", z.ZodTypeAny, {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                }, {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                }>>;
            }, "strip", z.ZodTypeAny, {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }, {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }>, "many">;
            connections: z.ZodArray<z.ZodObject<{
                from: z.ZodObject<{
                    insId: z.ZodString;
                    pinId: z.ZodString;
                }, "strict", z.ZodTypeAny, {
                    pinId?: string;
                    insId?: string;
                }, {
                    pinId?: string;
                    insId?: string;
                }>;
                to: z.ZodObject<{
                    insId: z.ZodString;
                    pinId: z.ZodString;
                }, "strict", z.ZodTypeAny, {
                    pinId?: string;
                    insId?: string;
                }, {
                    pinId?: string;
                    insId?: string;
                }>;
                delayed: z.ZodOptional<z.ZodBoolean>;
                hidden: z.ZodOptional<z.ZodBoolean>;
            }, "strict", z.ZodTypeAny, {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }, {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            connections?: {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }[];
            instances?: {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }[];
        }, {
            connections?: {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }[];
            instances?: {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }[];
        }>, z.ZodObject<{
            id: z.ZodOptional<z.ZodString>;
            inputs: z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodObject<{
                mode: z.ZodEnum<["required", "optional", "required-if-connected"]>;
                /** @deprecated */
                type: z.ZodOptional<z.ZodString>;
                description: z.ZodOptional<z.ZodString>;
                defaultValue: z.ZodOptional<z.ZodAny>;
            }, "strip", z.ZodTypeAny, {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }, {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }>]>>;
            outputs: z.ZodRecord<z.ZodString, z.ZodObject<{
                /** @deprecated */
                type: z.ZodOptional<z.ZodString>;
                optional: z.ZodOptional<z.ZodBoolean>;
                delayed: z.ZodOptional<z.ZodBoolean>;
                description: z.ZodOptional<z.ZodString>;
            }, "strip", z.ZodTypeAny, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }>>;
            inputsPosition: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
                x: z.ZodNumber;
                y: z.ZodNumber;
            }, "strict", z.ZodTypeAny, {
                x?: number;
                y?: number;
            }, {
                x?: number;
                y?: number;
            }>>>;
            outputsPosition: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
                x: z.ZodNumber;
                y: z.ZodNumber;
            }, "strict", z.ZodTypeAny, {
                x?: number;
                y?: number;
            }, {
                x?: number;
                y?: number;
            }>>>;
            completionOutputs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            reactiveInputs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            defaultStyle: z.ZodOptional<z.ZodObject<{
                size: z.ZodOptional<z.ZodEnum<["small", "regular", "large"]>>;
                icon: z.ZodOptional<z.ZodAny>;
                color: z.ZodOptional<z.ZodString>;
                cssOverride: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
            }, "strip", z.ZodTypeAny, {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            }, {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            }>>;
            description: z.ZodOptional<z.ZodString>;
            aliases: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            inputs?: Record<string, string | {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }>;
            outputs?: Record<string, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }>;
            completionOutputs?: string[];
            reactiveInputs?: string[];
            id?: string;
            description?: string;
            aliases?: string[];
            defaultStyle?: {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            };
            inputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
            outputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
        }, {
            inputs?: Record<string, string | {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }>;
            outputs?: Record<string, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }>;
            completionOutputs?: string[];
            reactiveInputs?: string[];
            id?: string;
            description?: string;
            aliases?: string[];
            defaultStyle?: {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            };
            inputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
            outputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
        }>>;
    }, "strict", z.ZodTypeAny, {
        node?: {
            connections?: {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }[];
            instances?: {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }[];
        } & {
            inputs?: Record<string, string | {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }>;
            outputs?: Record<string, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }>;
            completionOutputs?: string[];
            reactiveInputs?: string[];
            id?: string;
            description?: string;
            aliases?: string[];
            defaultStyle?: {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            };
            inputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
            outputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
        };
        imports?: Record<string, string | string[]>;
    }, {
        node?: {
            connections?: {
                from?: {
                    pinId?: string;
                    insId?: string;
                };
                to?: {
                    pinId?: string;
                    insId?: string;
                };
                delayed?: boolean;
                hidden?: boolean;
            }[];
            instances?: {
                id?: string;
                displayName?: string;
                config?: any;
                node?: any;
                type?: "code" | "visual";
                nodeId?: string;
                source?: {
                    type?: string;
                    data?: any;
                };
                macroId?: string;
                macroData?: any;
                inputConfig?: Record<string, {
                    mode?: "queue";
                } | {
                    mode?: "sticky";
                }>;
                visibleInputs?: string[];
                visibleOutputs?: string[];
                style?: {
                    size?: "small" | "regular" | "large";
                    icon?: any;
                    color?: string;
                    cssOverride?: Record<string, string>;
                };
                pos?: {
                    x?: number;
                    y?: number;
                };
            }[];
        } & {
            inputs?: Record<string, string | {
                description?: string;
                type?: string;
                mode?: "optional" | "required" | "required-if-connected";
                defaultValue?: any;
            }>;
            outputs?: Record<string, {
                description?: string;
                optional?: boolean;
                type?: string;
                delayed?: boolean;
            }>;
            completionOutputs?: string[];
            reactiveInputs?: string[];
            id?: string;
            description?: string;
            aliases?: string[];
            defaultStyle?: {
                size?: "small" | "regular" | "large";
                icon?: any;
                color?: string;
                cssOverride?: Record<string, string>;
            };
            inputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
            outputsPosition?: Record<string, {
                x?: number;
                y?: number;
            }>;
        };
        imports?: Record<string, string | string[]>;
    }>;
}

declare module '@flyde/core/node' {
    export * from "@flyde/core/node/node-instance";
    export * from "@flyde/core/types/pin-config";
    export * from "@flyde/core/node/node-instance-error";
    export * from "@flyde/core/node/node";
    export * from "@flyde/core/node/configurable-value";
}

declare module '@flyde/core/connect/helpers' {
    import { InputPin, NodeDefinition, OutputPin } from "@flyde/core/node";
    import { ConnectionData, ConnectionNode, ExternalConnectionNode, InternalConnectionNode } from "@flyde/core/types/connections";
    export const THIS_INS_ID = "__this";
    export const ERROR_PIN_ID = "__error";
    export const TRIGGER_PIN_ID = "__trigger";
    export const getNodeInputs: (node: NodeDefinition) => Record<string, InputPin>;
    export const getNodeOutputs: (node: NodeDefinition) => Record<string, OutputPin>;
    export const isExternalConnectionNode: (node: ConnectionNode) => node is ExternalConnectionNode;
    export const isInternalConnectionNode: (node: ConnectionNode) => node is InternalConnectionNode;
    export const isExternalConnection: ({ from, to }: ConnectionData) => boolean;
    export const isInternalConnection: (conn: ConnectionData) => boolean;
    export const externalConnectionNode: (pinId: string) => ExternalConnectionNode;
    export const connectionNode: (insId: string, pinId: string) => ConnectionNode;
    export const connectionNodeEquals: (conn1: ConnectionNode, conn2: ConnectionNode) => boolean;
    export const connectionDataEquals: (cd1?: ConnectionData, cd2?: ConnectionData) => boolean;
    export function connectionData(from: string, to: string, delayed?: boolean): ConnectionData;
    export function connectionData(from: [string, string], to: [string, string], delayed?: boolean): ConnectionData;
    export function connectionData(from: [string, string], to: [string], delayed?: boolean): ConnectionData;
    export function connectionData(from: [string], to: [string, string], delayed?: boolean): ConnectionData;
    export const connection: (from: ConnectionNode, to: ConnectionNode, delayed?: boolean) => ConnectionData;
}

declare module '@flyde/core/execute' {
    import { Subject } from "rxjs";
    export * from "@flyde/core/execute/debugger";
    import { InternalCodeNode, NodeInputs, NodeOutputs, NodeInstanceError, NodeState, InternalNode } from "@flyde/core/node";
    import { OMap, OMapF } from "@flyde/core/common";
    import { Debugger } from "@flyde/core/execute/debugger";
    export type SubjectMap = OMapF<Subject<any>>;
    export type ExecutionState = Map<string, any>;
    export type CancelFn = () => void;
    export type InnerExecuteFn = (node: InternalNode, args: NodeInputs, outputs: NodeOutputs, insId: string) => CancelFn;
    export type CodeExecutionData = {
            node: InternalCodeNode;
            inputs: NodeInputs;
            outputs: NodeOutputs;
            _debugger?: Debugger;
            /**
                * If the node is an instance of another node, this is the id of the instance.
                * If the node is the root node, this is "__root".
                * Used for debugger events and state namespacing
                */
            insId: string;
            /**
                * A full path of ancestor insIds, separated by dots.
                * Used for debugger events and state namespacing
                */
            ancestorsInsIds?: string;
            extraContext?: Record<string, any>;
            mainState: OMap<NodeState>;
            onError: (err: any) => void;
            onBubbleError: (err: any) => void;
            onCompleted?: (data: any) => void;
            onStarted?: () => void;
    };
    export const INNER_STATE_SUFFIX = "_inner";
    export const INPUTS_STATE_SUFFIX = "_inputs";
    export type ExecuteFn = (params: ExecuteParams) => CancelFn;
    export type ExecuteParams = {
            node: InternalNode;
            inputs: NodeInputs;
            outputs: NodeOutputs;
            _debugger?: Debugger;
            insId?: string;
            ancestorsInsIds?: string;
            mainState?: OMap<NodeState>;
            onBubbleError?: (err: NodeInstanceError) => void;
            extraContext?: Record<string, any>;
            onCompleted?: (data: any) => void;
            onStarted?: () => void;
    };
    export const ROOT_INS_ID = "__root";
    export const GLOBAL_STATE_NS = "____global";
    export const execute: ExecuteFn;
}

declare module '@flyde/core/simplified-execute' {
    import { InternalNode } from "@flyde/core/";
    import { ExecuteParams } from "@flyde/core/execute";
    export const simplifiedExecute: (nodeToRun: InternalNode, inputs?: Record<string, any>, onOutput?: (key: string, data: any) => void, otherParams?: Partial<ExecuteParams>) => import("./execute").CancelFn;
}

declare module '@flyde/core/types/connections' {
    import { THIS_INS_ID } from "@flyde/core/connect/helpers";
    export type ConnectionData = {
        from: ConnectionNode;
        to: ConnectionNode;
        delayed?: boolean;
        hidden?: boolean;
    };
    export type ExternalConnectionNode = {
        insId: typeof THIS_INS_ID;
        pinId: string;
    };
    export type InternalConnectionNode = {
        insId: string;
        pinId: string;
    };
    export type ConnectionNode = ExternalConnectionNode | InternalConnectionNode;
}

declare module '@flyde/core/types/editor' {
    import { CodeNodeDefinition, CodeNodeInstance, InternalCodeNode, ConfigurableEditorConfigResolved, ConfigurableEditorConfigStructured, NodeInstance, VisualNode } from "@flyde/core/node";
    export type EditorCodeNodeDefinition = CodeNodeDefinition & {
        editorConfig: ConfigurableEditorConfigStructured | {
            type: "custom";
            editorComponentBundleContent: string;
        };
    };
    export type EditorNode = EditorCodeNodeDefinition | EditorVisualNode;
    export type EditorCodeNodeInstance = CodeNodeInstance & {
        node: EditorCodeNodeDefinition;
    };
    export type EditorNodeInstance = NodeInstance & {
        node: EditorNode;
    };
    export type EditorVisualNode = Omit<VisualNode, "instances"> & {
        instances: EditorNodeInstance[];
    };
    export interface EditorNodeParams {
        sourceCode: string;
        editorConfig: ConfigurableEditorConfigResolved;
        isTrigger: boolean;
    }
    export function internalCodeNodeToEditorNode(internalNode: InternalCodeNode, { editorConfig, isTrigger, sourceCode }: EditorNodeParams): EditorNode;
}

declare module '@flyde/core/configurable-nodes/configurable-nodes' {
    import { InternalCodeNode, InputPin, OutputPin, InternalMacroNode, NodeStyle, InputMode } from "@flyde/core/";
    export * from "@flyde/core/configurable-nodes/configurable-node-utils";
    import { SecretTypeData } from "@flyde/core/node/configurable-value";
    export type StaticOrDerived<T, Config> = T | ((config: Config) => T);
    export interface BaseCodeNodeData<Config = any> {
            mode?: "simple" | "advanced";
            id: string;
            namespace?: string;
            menuDisplayName?: string;
            menuDescription?: string;
            displayName?: StaticOrDerived<string, Config>;
            description?: StaticOrDerived<string, Config>;
            overrideNodeBodyHtml?: StaticOrDerived<string, Config>;
            aliases?: string[];
            icon?: string;
            completionOutputs?: StaticOrDerived<string[], Config>;
            run: InternalCodeNode["run"];
            sourceCode?: string;
            /**
                * Whether this node is a trigger node.
                * If true, the node will be treated as a trigger node and will not be editable.
                * Experimental
                * @default false
                */
            isTrigger?: boolean;
    }
    export interface SimpleCodeNode<Config> extends BaseCodeNodeData<Config> {
            inputs: Record<string, InputConfig>;
            outputs: Record<string, {
                    description?: string;
            }>;
    }
    export interface AdvancedCodeNode<Config> extends BaseCodeNodeData<Config> {
            mode: "advanced";
            inputs: StaticOrDerived<Record<string, InputPin>, Config>;
            outputs: StaticOrDerived<Record<string, OutputPin>, Config>;
            reactiveInputs?: StaticOrDerived<string[], Config>;
            defaultConfig: Config;
            editorConfig?: InternalMacroNode<Config>["editorConfig"];
            defaultStyle?: NodeStyle;
    }
    export type CodeNode<Config = any> = SimpleCodeNode<Config> | AdvancedCodeNode<Config>;
    export type InputConfig = {
            defaultValue?: any;
            /**
                * The label displayed above the input field.
                * If not provided, the description will be used as the label.
                * @recommended
                */
            label?: string;
            description?: string;
            mode?: InputMode | "reactive";
            /**
                * Whether the type of this input can be changed in the editor.
                * When false, the "Change type" button will not be shown and the input won't be exposed as an input pin.
                * @default true
                */
            typeConfigurable?: boolean;
            aiCompletion?: {
                    prompt: string;
                    placeholder?: string;
                    jsonMode?: boolean;
            };
            /**
                * Optional condition that determines whether this input should be shown.
                * If the condition evaluates to false, the input will be hidden.
                *
                * Uses a string expression like "method !== 'GET'" that will be evaluated against the config.
                * The expression can reference other field values directly by their key.
                *
                * @example
                * condition: "method !== 'GET'"
                */
            condition?: string;
            /**
                * Optional group configuration for organizing inputs.
                * When specified, this input will be treated as a group container.
                */
            group?: {
                    /**
                        * The title of the group
                        */
                    title: string;
                    /**
                        * Whether the group is collapsible
                        */
                    collapsible?: boolean;
                    /**
                        * Whether the group is collapsed by default (only applies if collapsible is true)
                        */
                    defaultCollapsed?: boolean;
                    /**
                        * Fields to include in this group.
                        * Can include both regular field keys and other group keys for nested groups.
                        */
                    fields: string[];
                    /**
                        * Optional parent group key. When specified, this group will be nested inside the parent group.
                        * If not specified, the group will be at the top level.
                        */
                    parentGroup?: string;
            };
    } & EditorTypeConfig;
    type EditorTypeConfig = {
            [K in EditorType]: {
                    editorType?: K;
                    editorTypeData?: EditorTypeDataMap[K];
            };
    }[EditorType];
    type EditorType = "string" | "number" | "boolean" | "json" | "select" | "longtext" | "enum" | "secret";
    type EditorTypeDataMap = {
            string: undefined;
            number: {
                    min?: number;
                    max?: number;
            };
            boolean: undefined;
            json: undefined;
            select: {
                    options: string[] | {
                            value: string | number;
                            label: string;
                    }[];
            };
            longtext: {
                    rows?: number;
            };
            enum: {
                    options: string[];
            };
            secret: SecretTypeData;
    };
    export function isAdvancedCodeNode<Config>(node: CodeNode<Config>): node is AdvancedCodeNode<Config>;
    export function isSimplifiedCodeNode<Config>(node: CodeNode<Config>): node is SimpleCodeNode<Config>;
    export function isCodeNode<Config>(node: any): node is CodeNode<Config>;
    export function processConfigurableNode(node: CodeNode, secrets?: Record<string, string>): InternalMacroNode<any>;
}

declare module '@flyde/core/configurable-nodes/configurable-node-utils' {
    import { InputPin, ConfigurableValue, ConfigurableFieldDefinition, InternalMacroNode, InputMode } from "@flyde/core/";
    import { InputConfig } from "@flyde/core/configurable-nodes/configurable-nodes";
    export function extractInputsFromValue(_val: unknown, key: string, mode?: InputMode): Record<string, InputPin>;
    export function replaceInputsInValue(inputs: Record<string, any>, value: ConfigurableValue, fieldName: string, ignoreMissingInputs?: boolean): ConfigurableValue["value"];
    export function renderConfigurableValue(value: ConfigurableValue, fieldName: string): string;
    export function generateConfigEditor<Config>(config: Config, overrides?: Partial<Record<keyof Config, any>>): InternalMacroNode<Config>["editorConfig"];
    export function renderDerivedString(displayName: string, config: any): string;
    /**
        * Evaluates a string condition against a configuration object.
        *
        * @param condition The string expression to evaluate
        * @param config The configuration object to evaluate against
        * @returns True if the condition is met, false otherwise
        */
    export function evaluateCondition(condition: string | undefined, config: Record<string, any>): boolean;
    /**
        * Evaluates whether a field in a group hierarchy should be visible.
        * A field is visible only if all its parent groups are visible.
        *
        * @param field The field to check visibility for
        * @param fieldPath Array of parent group field IDs leading to this field
        * @param allFields Map of all fields by their ID
        * @param config The configuration object to evaluate conditions against
        * @returns True if the field should be visible, false otherwise
        */
    export function evaluateFieldVisibility(fieldKey: string, groupHierarchy: string[], allFields: Record<string, ConfigurableFieldDefinition>, config: Record<string, any>): boolean;
    /**
        * Creates a group configuration for use in InputConfig.
        *
        * @param title The title of the group
        * @param fields Array of field keys to include in the group
        * @param options Additional group options
        * @returns A group configuration object
        */
    export function createInputGroup(title: string, fields: string[], options?: {
            collapsible?: boolean;
            defaultCollapsed?: boolean;
            parentGroup?: string;
            condition?: string;
    }): NonNullable<InputConfig["group"]> & {
            condition?: string;
    };
}

declare module '@flyde/core/remote-debugger' {
    export * from "@flyde/core/remote-debugger/types";
    export * from "@flyde/core/remote-debugger/utils";
}

declare module '@flyde/core/run-node' {
    import { ExecuteParams, InternalNode } from "@flyde/core/";
    export interface RunNodeOptions extends Omit<ExecuteParams, 'node' | 'inputs' | 'outputs'> {
        onOutputs?: (key: string, data: any) => void;
        executionDelay?: number;
    }
    export function runNode<TInputs = any, TOutputs = any>(node: InternalNode, inputs: TInputs, options?: RunNodeOptions): Promise<TOutputs>;
}

declare module '@flyde/core/telemetry' {
    export interface TelemetryEvent {
        distinctId: string;
        event: string;
        properties?: Record<string, any>;
    }
    export function reportEvent(distinctId: string, event: string, properties?: Record<string, any>): void;
}

declare module '@flyde/core/common/test-data-creator' {
    export type TestDataCreator<T> = (partial?: Partial<T>) => T;
    export type ObjOrObjCreator<T> = T | (() => T);
    export const testDataCreator: <T extends object>(defaults: ObjOrObjCreator<T>) => TestDataCreator<T>;
}

declare module '@flyde/core/common/utils' {
    export type Pos = {
        x: number;
        y: number;
    };
    export interface OMap<T> {
        [k: string]: T | undefined;
    }
    export interface OMapF<T> {
        [k: string]: T;
    }
    export type Rect = Pos & {
        w: number;
        h: number;
    };
    export const intersectRect: (r1: Rect, r2: Rect) => boolean;
    export const calcCenter: ({ w, h, x, y }: Rect) => Pos;
    export const middlePos: (p1: Pos, p2: Pos) => Pos;
    export const mapOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => T) => OMap<T>;
    export const filterOMap: <T>(map: OMap<T>, cb: (key: string, item: T) => boolean) => OMap<T>;
    export const keys: <V>(map: OMap<V>) => string[];
    export const values: <V>(map: OMap<V>) => V[];
    export const entries: <V>(map: OMap<V>) => Array<[string, V]>;
    export const fromEntries: <V>(entries: Array<[string, V]>) => OMap<V>;
    export const pickFirst: <K>(v: [K, any]) => K;
    export const pickSecond: <K>(v: [any, K]) => K;
    export type RandomFunction = {
        (): number;
        (max: number): number;
        (max: number, min: number): number;
    };
    export const randomInt: RandomFunction;
    export const randomPos: (to?: number, from?: number) => Pos;
    export const pickRandom: <K>(v: K[]) => K;
    export const repeat: <T>(count: number, run: (idx: number) => T) => T[];
    export const randomInts: (count: number, to?: number, from?: number) => number[];
    export const shuffle: (arr: any[]) => any[];
    export const containsAll: <T>(arr: T[], items: T[]) => boolean;
    export const isDefined: <T>(o: T) => o is NonNullable<T>;
    export const isPromise: <T>(o: any) => o is Promise<T>;
    export const callFnOrFnPromise: (maybeFnOrFnPromise: void | Function | Promise<void | Function>, errorMsg: string) => void;
    export const isOptionalType: (type: string) => boolean;
    export const ensure: <T>(v: T, msg?: string) => NonNullable<T>;
    export const removeDupes: (list: string[]) => string[];
    export const noop: () => void;
    export const delay: (ms: number) => Promise<unknown>;
    export const eventually: (callback: () => void, timeout?: number, retryDelay?: number, errorSet?: Set<string>) => Promise<void>;
    export function simplePluralize(count: number, noun: string): string;
}

declare module '@flyde/core/common/debug-logger' {
    import type { Debugger as _Debugger } from "debug";
    export type DebugLogger = _Debugger;
    export const debugLogger: (subNs: string) => DebugLogger;
}

declare module '@flyde/core/common/capped-array-debounce' {
    export const cappedArrayDebounce: <T>(cb: (items: T[]) => void, timeout: number, maxItems: number, maxTimeWaiting?: number) => {
        addItem: (item: T) => void;
        flush: () => void;
        pendingItems: () => number;
    };
}

declare module '@flyde/core/common/value-builders' {
    import { OMap } from "@flyde/core/common";
    export const compileStringTemplate: (template: string, inputs: OMap<any>) => string;
    export const compileObjectTemplate: (template: string, inputs: OMap<any>) => any;
}

declare module '@flyde/core/common/data-shaper' {
    export enum DataShapeType {
        STRING = 0,
        NUMBER = 1,
        BOOLEAN = 2,
        ARRAY = 3,
        OBJECT = 4,
        NULL = 5,
        UNSUPPORTED = 6
    }
    export type DataShaperOptions = {
        maxDepth: number;
        maxArrayCheckIdx: number;
    };
    export type DataShape = DataShapeType | DataShape[] | {
        [key: string]: DataShape;
    };
    export const dataShaper: (data: any, maxDepth?: number, maxArrayCheckIdx?: number) => DataShape;
}

declare module '@flyde/core/common/full-ins-id-path' {
    export function fullInsIdPath(insId: string, ancestorsInsIds?: string): string;
}

declare module '@flyde/core/node/node-instance' {
    import { InputPinsConfig, NodeDefinition, NodeStyle, Pos, VisualNode } from "@flyde/core/";
    export interface NodeInstanceConfig {
            inputConfig: InputPinsConfig;
            visibleInputs?: string[];
            visibleOutputs?: string[];
            displayName?: string;
            style?: NodeStyle;
            id: string;
            pos: Pos;
    }
    export interface CodeNodeSource {
            type: "package" | "file" | "custom";
            data: any;
    }
    export interface CodeNodeInstance extends NodeInstanceConfig {
            type: "code";
            nodeId: string;
            source: CodeNodeSource;
            config: any;
            /**
                * @deprecated Use nodeId instead
                */
            macroId?: string;
            /**
                * @deprecated Use config instead
                */
            macroData?: any;
    }
    export interface VisualNodeSourceRef {
            type: "package" | "file" | "custom";
            data: string;
    }
    export interface VisualNodeSourceInline {
            type: "inline";
            data: VisualNode;
    }
    export interface VisualNodeSourceSelf {
            type: "self";
    }
    export type VisualNodeSource = VisualNodeSourceRef | VisualNodeSourceInline | VisualNodeSourceSelf;
    export interface VisualNodeInstance extends NodeInstanceConfig {
            type: "visual";
            nodeId: string;
            source: VisualNodeSource;
    }
    /** @deprecated */
    export interface RefNodeInstance extends NodeInstanceConfig {
            nodeId: string;
            source?: CodeNodeSource;
            config?: any;
    }
    /** @deprecated */
    export interface InlineNodeInstance extends NodeInstanceConfig {
            node: VisualNode;
    }
    export type NodeInstance = CodeNodeInstance | VisualNodeInstance;
    export type ResolvedNodeInstance = NodeInstance;
    export function codeNodeInstance(id: string, nodeId: string, source: CodeNodeSource, config?: any, inputConfig?: InputPinsConfig, pos?: Pos): CodeNodeInstance;
    export const isCodeNodeInstance: (ins: NodeInstance) => ins is CodeNodeInstance;
    export const isVisualNodeInstance: (ins: NodeInstance) => ins is VisualNodeInstance;
    export const isInlineVisualNodeInstance: (ins: NodeInstance) => ins is VisualNodeInstance & {
            source: VisualNodeSourceInline;
    };
    export const createInsId: (node: Pick<NodeDefinition, "id">) => string;
}

declare module '@flyde/core/types/pin-config' {
    import { OMap } from "@flyde/core/";
    export type QueueInputPinConfig = {
        mode: "queue";
    };
    export type StickyInputPinConfig = {
        mode: "sticky";
    };
    export type InputPinConfig = QueueInputPinConfig | StickyInputPinConfig;
    export type InputPinsConfig = OMap<InputPinConfig>;
    export const queueInputPinConfig: () => QueueInputPinConfig;
    export const stickyInputPinConfig: () => StickyInputPinConfig;
    export const isQueueInputPinConfig: (config: InputPinConfig | undefined) => config is QueueInputPinConfig;
    export const isStickyInputPinConfig: (config: InputPinConfig | undefined) => config is StickyInputPinConfig;
}

declare module '@flyde/core/node/node-instance-error' {
    export class NodeInstanceError extends Error {
        fullInsIdsPath: string;
        nodeId: string;
        constructor(error: unknown, fullInsIdsPath: string, nodeId: string);
    }
}

declare module '@flyde/core/node/node' {
    import { OMapF } from "@flyde/core/common";
    import { Subject } from "rxjs";
    import { CancelFn, InnerExecuteFn } from "@flyde/core/execute";
    import { ConfigurableNodeDefinition } from "@flyde/core/node/configurable-value";
    import { VisualNode } from "@flyde/core/types/external";
    import { CodeNodeDefinition } from "@flyde/core/types/external";
    export type NodeState = Map<string, any>;
    export type NodeAdvancedContext = {
        execute: InnerExecuteFn;
        insId: string;
        ancestorsInsIds?: string;
        state: NodeState;
        globalState: NodeState;
        onCleanup: (cb: Function) => void;
        onError: (e: any) => void;
        context: Record<string, any>;
    };
    export type RunNodeFunction = (args: OMapF<any>, o: OMapF<Subject<any>>, adv: NodeAdvancedContext) => void | CancelFn | Promise<void | CancelFn>;
    export * from "@flyde/core/node/configurable-value";
    export type NodeDefinition = VisualNode | CodeNodeDefinition;
    export type NodeOrConfigurableDefinition = NodeDefinition | ConfigurableNodeDefinition<any>;
    export * from "@flyde/core/node/node-instance";
    export * from "@flyde/core/types/internal";
    export * from "@flyde/core/types/core";
    export * from "@flyde/core/types/external";
    export * from "@flyde/core/types/pins";
}

declare module '@flyde/core/node/configurable-value' {
    import { InternalCodeNode, CodeNodeDefinition, NodeMetadata, CodeNodeInstance } from "@flyde/core/node/node";
    import type React from "react";
    export function configurableValue(type: ConfigurableValue["type"], value: ConfigurableValue["value"]): ConfigurableValue;
    import { CodeNode } from "@flyde/core/configurable-nodes/configurable-nodes";
    export type ConfigurableFieldDefinitionType = "string" | "number" | "boolean" | "json" | "select" | "longtext" | "dynamic" | "secret";
    export type ConfigurableValueTypeMap = {
            string: string;
            number: number;
            boolean: boolean;
            json: any;
            select: string | number;
            dynamic: undefined;
            secret: string;
    };
    export type ConfigurableValue = {
            [K in keyof ConfigurableValueTypeMap]: {
                    type: K;
                    value: ConfigurableValueTypeMap[K];
            };
    }[keyof ConfigurableValueTypeMap];
    export type ConfigurableFieldDefinition = StringFieldDefinition | NumberFieldDefinition | BooleanFieldDefinition | JsonFieldDefinition | SelectFieldDefinition | LongTextFieldDefinition | GroupFieldDefinition | SecretFieldDefinition;
    interface BaseFieldDefinition {
            label: string;
            description?: string;
            configKey: string;
            templateSupport?: boolean;
            typeConfigurable?: boolean;
            aiCompletion?: {
                    prompt: string;
                    placeholder?: string;
                    jsonMode?: boolean;
            };
            /**
                * Optional condition that determines whether this field should be shown.
                * If the condition evaluates to false, the field will be hidden.
                *
                * Uses a string expression like "method !== 'GET'" that will be evaluated against the values.
                * The expression can reference other field values directly by their key.
                *
                * @example
                * condition: "method === 'POST'"
                */
            condition?: string;
    }
    export interface StringFieldDefinition extends BaseFieldDefinition {
            type: "string";
    }
    export interface BooleanFieldDefinition extends BaseFieldDefinition {
            type: "boolean";
    }
    export interface JsonFieldDefinition extends BaseFieldDefinition {
            type: "json";
            typeData?: {
                    helperText?: string;
            };
    }
    export interface LongTextFieldDefinition extends BaseFieldDefinition {
            type: "longtext";
            typeData?: {
                    rows?: number;
            };
    }
    export interface NumberFieldDefinition extends BaseFieldDefinition {
            type: "number";
            typeData?: NumberTypeData;
    }
    export interface SelectFieldDefinition extends BaseFieldDefinition {
            type: "select";
            typeData: SelectTypeData;
    }
    export interface SecretFieldDefinition extends BaseFieldDefinition {
            type: "secret";
            typeData: SecretTypeData;
    }
    export interface NumberTypeData {
            min?: number;
            max?: number;
    }
    export interface SecretTypeData {
            defaultName?: string;
    }
    export interface SelectTypeData {
            options: {
                    value: string | number;
                    label: string;
            }[];
    }
    export interface ConfigurableEditorConfigCustom {
            type: "custom";
            editorComponentBundlePath?: string;
            editorComponentBundleContent?: string;
    }
    export interface ConfigurableEditorConfigStructured {
            type: "structured";
            fields: ConfigurableFieldDefinition[];
    }
    export type ConfigurableEditorConfigResolved = ConfigurableEditorConfigCustom | ConfigurableEditorConfigStructured;
    export type ConfigurableEditorConfigDefinition = ConfigurableEditorConfigCustom | ConfigurableEditorConfigStructured;
    export interface InternalMacroNode<T = any> extends NodeMetadata {
            definitionBuilder: (data: T) => Omit<CodeNodeDefinition, "id" | "namespace">;
            runFnBuilder: (data: T) => InternalCodeNode["run"];
            defaultData: T;
            /**
                * Assumes you are bundling the editor component using webpack library+window config.
                * The name of the window variable that holds the component should be __MacroNode__{id}
                * The path should be relative to the root of the project (package.json location)
                */
            editorConfig: ConfigurableEditorConfigResolved;
    }
    export type ConfigurableNodeDefinition<T> = Omit<InternalMacroNode<T>, "definitionBuilder" | "runFnBuilder" | "editorComponentBundlePath" | "editorConfig"> & {
            /**
                * Resolver will use this to load the editor component bundle into the editor
                */
            editorConfig: ConfigurableEditorConfigDefinition;
            sourceCode?: string;
    };
    export interface AiCompletionDto {
            prompt: string;
            nodeId: string;
            insId: string;
            jsonMode?: boolean;
    }
    export interface PartialEditorPorts {
            getAvailableSecrets: () => Promise<string[]>;
            addNewSecret: (dto: {
                    key: string;
                    value: string;
            }) => Promise<string[]>;
            prompt: ({ text, defaultValue }: {
                    text: string;
                    defaultValue?: string;
            }) => Promise<string | null>;
            createAiCompletion?: (dto: AiCompletionDto) => Promise<string>;
    }
    export interface ConfigurableEditorCompProps<T> {
            value: T;
            onChange: (value: T) => void;
            ports: PartialEditorPorts;
            insId?: string;
            nodeId: string;
            createAiCompletion?: PartialEditorPorts['createAiCompletion'];
    }
    export interface ConfigurableEditorComp<T> extends React.FC<ConfigurableEditorCompProps<T>> {
    }
    export const isInternalMacroNode: (p: any) => p is InternalMacroNode<any>;
    export function processConfigurableNodeInstance(prefix: string, _macro: InternalMacroNode<any> | CodeNode, instance: Pick<CodeNodeInstance, "id" | "config">, secrets?: Record<string, string>): InternalCodeNode;
    export interface GroupFieldDefinition extends BaseFieldDefinition {
            type: "group";
            fields: ConfigurableFieldDefinition[];
            typeData?: {
                    /**
                        * Whether the group is collapsible
                        */
                    collapsible?: boolean;
                    /**
                        * Whether the group is collapsed by default (only applies if collapsible is true)
                        */
                    defaultCollapsed?: boolean;
            };
    }
    export function isConfigurableValue(value: any): value is ConfigurableValue;
    export {};
}

declare module '@flyde/core/execute/debugger' {
    import { DebuggerEvent } from "@flyde/core/execute/debugger/events";
    export * from "@flyde/core/execute/debugger/events";
    export * from "@flyde/core/execute/debugger/format-event";
    export type DebuggerInterceptCommand = {
        cmd: "intercept";
        valuePromise: Promise<any>;
    };
    export type DebuggerCommand = DebuggerInterceptCommand | void;
    export type Debugger = {
        onEvent?: <T extends DebuggerEvent>(event: Omit<T, "time" | "executionId">) => DebuggerCommand;
        debugDelay?: number;
        destroy?: () => void;
    };
}

declare module '@flyde/core/' {
    export * from "@flyde/core/common";
    import { Pos } from "@flyde/core/common";
    import { FlydeFlow } from "@flyde/core/flow-schema";
    import { VisualNode, InputPinsConfig } from "@flyde/core/node";
    export * from "@flyde/core/connect/helpers";
    export * from "@flyde/core/execute";
    export * from "@flyde/core/simplified-execute";
    export * from "@flyde/core/node";
    export * from "@flyde/core/flow-schema";
    export * from "@flyde/core/types/connections";
    export * from "@flyde/core/types/editor";
    export * from "@flyde/core/configurable-nodes/configurable-nodes";
    export { extractInputsFromValue, replaceInputsInValue, renderDerivedString, evaluateCondition, evaluateFieldVisibility, createInputGroup, } from "@flyde/core/configurable-nodes/configurable-node-utils";
    export * from "@flyde/core/remote-debugger";
    export * from "@flyde/core/run-node";
    export interface InstanceViewData {
        id: string;
        nodeIdOrGroup: string | VisualNode;
        pos: Pos;
        visibleOptionalInputs?: string[];
        inputConfig: InputPinsConfig;
    }
    export interface FlowJob {
        flow: FlydeFlow;
        id: string;
    }
    export * from "@flyde/core/telemetry";
}

declare module '@flyde/core/remote-debugger/types' {
    import { DebuggerEvent } from "@flyde/core/execute/debugger/events";
    export type RemoteDebuggerCallback<T> = (data: T) => void;
    export type RemoteDebuggerCancelFn = () => void;
    export enum DebuggerServerEventType {
        RUNTIME_READY = "runtime-ready",
        CHANGE_EVENT_NAME = "change",
        PUSH_INPUT_VALUE = "push-input-value",
        CHANGE_AWK = "live-change-awk",
        CHANGE_ERROR = "live-change-error",
        IS_ALIVE = "is-alive",
        UPDATE_BREAKPOINTS = "update-breakpoints",
        INPUT_VALUE_OVERRIDE = "input-value-override",
        OUTPUT_VALUE_OVERRIDE = "output-value-override",
        INPUT_VALUE_CHANGE = "input-value-changed",
        OUTPUT_VALUE_CHANGE = "output-value-changed",
        PROCESSING_CHANGE = "processing-changed",
        INPUTS_STATE_CHANGE = "inputs-state-changed",
        NODE_ERROR = "node-error",
        EVENTS_BATCH = "events-batch"
    }
    export type HistoryPayload = {
        total: number;
        lastSamples: DebuggerEvent[];
    };
}

declare module '@flyde/core/remote-debugger/utils' {
    export const toString: (v: any) => string;
    export const valuePreview: (v: any) => string;
    export const isSimpleType: (v: any) => boolean;
    export const isNumber: (v: any) => boolean;
    export function enumToArray(aEnum: any): any[];
}

declare module '@flyde/core/types/external' {
    /**
        * A visual node is what makes Flyde special. It represents a node created visually in the editor.
        * It consists of node instances and connections. Each node instance will either refer to an imported node (by id), or include the node "inline".
        * Each connection will represent a "wire" between 2 instances, or between an instance and a main input/output pin.
        * Connecting to a main input or output is the way that a visual nodes' internal implementation can communicate with its external API.
        */
    import { CodeNode, CodeNodeInstance, CodeNodeSource, EditorNodeInstance, InputPinsConfig, NodeInstance, VisualNodeInstance, VisualNodeSource } from "@flyde/core/";
    import { OMap, Pos } from "@flyde/core/common";
    import { ConnectionData } from "@flyde/core/types/connections";
    import { BaseNode } from "@flyde/core/types/core";
    import { InternalCodeNode } from "@flyde/core/types/internal";
    export interface VisualNode extends BaseNode {
            /** a map holding the position for each main input. Used in the editor only. */
            inputsPosition: OMap<Pos>;
            /** a map holding the position for each main output. Used in the editor only. */
            outputsPosition: OMap<Pos>;
            /** the visual nodes internal node instances, either referring to other nodes by id or by value (inline) */
            instances: NodeInstance[];
            /** each connection represents a "wire" between 2 different instances, or between an instance and a main input/output*/
            connections: ConnectionData[];
    }
    export const isVisualNode: (p: FlydeNode) => p is VisualNode;
    export const visualNode: import("..").TestDataCreator<VisualNode>;
    export function nodeInstance(insId: string, nodeId: string, source: CodeNodeSource, config?: any, inputConfig?: InputPinsConfig, pos?: Pos): CodeNodeInstance;
    export function visualNodeInstance(insId: string, nodeId: string, source: VisualNodeSource, inputConfig?: InputPinsConfig, pos?: Pos): VisualNodeInstance;
    export function inlineVisualNodeInstance(insId: string, node: VisualNode, inputConfig?: InputPinsConfig, pos?: Pos): VisualNodeInstance;
    export type CodeNodeDefinition = Omit<InternalCodeNode, "run"> & {
            /**
                * The source code of the node, if available. Used for editing and forking nodes in the editor.
                */
            sourceCode?: string;
            /**
                * Whether this node is a trigger node.
                * If true, the node will be treated as a trigger node and will not be editable.
                * Experimental
                * @default false
                */
            isTrigger?: boolean;
    };
    export type FlydeNode<T = any> = VisualNode | CodeNode<T>;
    export type ImportableEditorNode = {
            id: string;
            displayName: string;
            description: string;
            icon: string;
            aliases?: string[];
            editorNode: EditorNodeInstance['node'];
    } & ({
            type: "code";
            source: CodeNodeSource;
            config: any;
    } | {
            type: "visual";
            source: VisualNodeSource;
    });
    export function codeNodeToImportableEditorNode(node: CodeNode, source: CodeNodeSource): ImportableEditorNode;
    export function visualNodeToImportableEditorNode(node: VisualNode, source: VisualNodeSource): ImportableEditorNode;
    export interface NodeLibraryGroup {
            title: string;
            nodes: ImportableEditorNode[];
    }
    export interface NodeLibraryData {
            groups: NodeLibraryGroup[];
    }
}

declare module '@flyde/core/types/internal' {
    import { InputPinsConfig, RunNodeFunction } from "@flyde/core/node";
    import { ConnectionData } from "@flyde/core/types/connections";
    import { BaseNode } from "@flyde/core/types/core";
    export interface InternalCodeNode extends BaseNode {
        /**
          * This function will run as soon as the node's inputs are satisfied.
          * It has access to the nodes inputs values, and output pins. See {@link RunNodeFunction} for more information.
          *
          */
        run: RunNodeFunction;
    }
    export interface InternalCodeNodeInstance {
        id: string;
        node: InternalCodeNode;
        inputConfig: InputPinsConfig;
    }
    export interface InternalInlineNodeInstance {
        id: string;
        node: InternalVisualNode;
        inputConfig: InputPinsConfig;
    }
    export type InternalNodeInstance = InternalCodeNodeInstance | InternalInlineNodeInstance;
    export function isInternalInlineNodeInstance(instance: InternalNodeInstance): instance is InternalInlineNodeInstance;
    export interface InternalVisualNode extends BaseNode {
        /** the visual nodes internal node instances, either referring to other nodes by id or by value (inline) */
        instances: InternalNodeInstance[];
        /** each connection represents a "wire" between 2 different instances, or between an instance and a main input/output*/
        connections: ConnectionData[];
    }
    export type InternalNode = InternalCodeNode | InternalVisualNode;
    export function internalNodeInstance(insId: string, node: InternalNode, inputConfig?: InputPinsConfig): InternalNodeInstance;
    export function isInternalVisualNode(node: InternalNode): node is InternalVisualNode;
}

declare module '@flyde/core/types/core' {
    import { InputPin, OutputPin } from "@flyde/core/types/pins";
    export type NodeTypeIcon = string | [string, string];
    export interface NodeStyle {
            color?: string | [string, string];
            cssOverride?: Record<string, string>;
    }
    export interface NodeMetadata {
            /**
                * Node's unique id. {@link VisualNode.instances }  refer use this to refer to the correct node
                */
            id: string;
            /**
                * A human readable name for the node. Used in the visual editor.
                */
            displayName?: string;
            menuDisplayName?: string;
            /**
                * Is displayed in the visual editor and used to search for nodes.
                */
            description?: string;
            /**
                * A list of keywords that can be used to search for the node. Useful for node that users might search using different words.
                */
            aliases?: string[];
            /**
                * TBD
                */
            namespace?: string;
            icon?: string;
            /**
                * All instances of this node will inherit the default style if it is supplied.
                * See {@link NodeStyle} for the full options supported
                */
            defaultStyle?: NodeStyle;
            /**
                * Hack to support note node without adding first class support for it.
                * This is used to override the node body html for a node.
                */
            overrideNodeBodyHtml?: string;
    }
    /**
        * Extended by {@link VisualNode}, {@link InternalCodeNode} and {@link InlineValueNode}
        */
    export interface BaseNode extends NodeMetadata {
            /**
                * A pin on a node that receives data. Each node can have zero or more input pins.
                *
                * Example for the inputs of a mathematical multiplier node:
                * ```ts
                * {
                *  multiplicand: { description: "The number to be multiplied" },
                *  multiplier: { description: "The number with which we multiply" },
                * }
                * ```
                */
            inputs: Record<string, InputPin>;
            /**
                * A pin on a node that sends data. Each node can have zero or more output pins.
                * For example, a "Split array" node might have one input pin for an array and two output pins for the first and second halves of the array:
                *
                * @example
                * ```ts
                * {
                *  'first half': { description: "The first half of the array" },
                *  'second half': { description: "The second half of the array" },
                * }
                * ```
                */
            outputs: Record<string, OutputPin>;
            /**
                * Instructs Flyde that the node is in "explicit completion" mode and describes which outputs trigger the node's completion. Receives a list of outputs that should trigger an explicit completion of the node when they emit a value. Any of the listed outputs will trigger a completion (i.e. completionOutput[0] `OR` completionOutput[1])
                * Leave empty for implicit completion. This should work best for 99% of the case.
                *
                * To declare that 2 different outputs must emit a value in order to trigger a completion, different outputs can be joined together with a `+` sign as following:
                * ``` ts
                * {
                * ...
                *  completionOutputs: ["data+headers", "error"] // this means either data AND headers, OR "error" will trigger an explicit completion.
                * ```
                *
                * See the [Nodes lifecycle](/docs/lifecycle) for more info
                */
            completionOutputs?: string[];
            /**
                * @deprecated - TBD
                */
            reactiveInputs?: string[];
    }
}

declare module '@flyde/core/types/pins' {
    import { Subject } from "rxjs";
    import { OMapF } from "@flyde/core/";
    import { QueueInputPinConfig, StickyInputPinConfig } from "@flyde/core/types/pin-config";
    export type PinType = "input" | "output";
    export type InputMode = "optional" | "required" | "required-if-connected";
    export interface BasePinData {
        description?: string;
    }
    export interface InputPin extends BasePinData {
        mode?: InputMode;
    }
    export type InputPinMap = Record<string, InputPin>;
    export type OutputPinMap = Record<string, OutputPin>;
    export interface OutputPin extends BasePinData {
        delayed?: boolean;
    }
    export const nodeInput: (mode?: InputMode) => InputPin;
    export const isInputPinOptional: (input: InputPin) => boolean;
    export const nodeInputs: (count: number, modes?: InputMode[]) => InputPin[];
    export const nodeOutput: (delayed?: boolean) => OutputPin;
    export const nodeOutputs: (count: number) => OutputPin[];
    export type DynamicNodeInput = {
        subject: Subject<any>;
        config: StickyInputPinConfig | QueueInputPinConfig;
    };
    export type NodeInput = DynamicNodeInput;
    export type NodeOutput = Subject<any>;
    export type NodeOutputs = OMapF<NodeOutput>;
    export type NodeInputs = OMapF<NodeInput>;
    export interface DynamicOutput extends Subject<any> {
    }
    export const dynamicOutput: () => DynamicOutput;
    export const dynamicNodeInput: import("..").TestDataCreator<DynamicNodeInput>;
    export const dynamicNodeInputs: (count?: number) => DynamicNodeInput[];
}

declare module '@flyde/core/execute/debugger/events' {
    import { OMap } from "@flyde/core/";
    export enum DebuggerEventType {
        INPUT_CHANGE = "i",
        OUTPUT_CHANGE = "o",
        PROCESSING_CHANGE = "pc",
        ERROR = "err",
        INPUTS_STATE_CHANGE = "isc"
    }
    export const MAJOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];
    export const MINOR_DEBUGGER_EVENT_TYPES: DebuggerEventType[];
    export type BaseDebuggerEvent<T extends DebuggerEventType> = {
        type: T;
        insId: string;
        ancestorsInsIds?: string;
        nodeId: string;
        val: DebuggerEventTypeData[T];
        time: number;
        executionId: string;
    };
    export type PinDebuggerEvent<T extends DebuggerEventType> = {
        pinId: string;
    } & BaseDebuggerEvent<T>;
    export type DebuggerEventTypeData = {
        [DebuggerEventType.INPUTS_STATE_CHANGE]: OMap<number>;
        [DebuggerEventType.PROCESSING_CHANGE]: boolean;
        [DebuggerEventType.ERROR]: any;
        [DebuggerEventType.INPUT_CHANGE]: string;
        [DebuggerEventType.OUTPUT_CHANGE]: string;
    };
    export type MajorDebuggerEvent = PinDebuggerEvent<DebuggerEventType.OUTPUT_CHANGE> | PinDebuggerEvent<DebuggerEventType.INPUT_CHANGE> | BaseDebuggerEvent<DebuggerEventType.ERROR>;
    export type MinorDebuggerEvent = BaseDebuggerEvent<DebuggerEventType.INPUTS_STATE_CHANGE> | BaseDebuggerEvent<DebuggerEventType.PROCESSING_CHANGE>;
    export type DebuggerEvent = MajorDebuggerEvent | MinorDebuggerEvent;
}

declare module '@flyde/core/execute/debugger/format-event' {
    import { DebuggerEvent } from "@flyde/core/execute/debugger/events";
    export function formatEvent(event: DebuggerEvent): string;
}

